#!/bin/bash

set -e

JOURNAL_DIR="$HOME/journalot"
CONFIG_FILE="$HOME/.journalotrc"

# Load config if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Error handling
error_exit() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success_msg() {
    echo -e "${GREEN}$1${NC}"
}

warn_msg() {
    echo -e "${YELLOW}$1${NC}"
}

# Check dependencies
check_dependencies() {
    if ! command -v git &> /dev/null; then
        error_exit "git is not installed. Please install git first."
    fi
}

# Determine editor
get_editor() {
    if [ -n "$EDITOR" ]; then
        echo "$EDITOR"
    elif command -v code &> /dev/null; then
        echo "code"
    elif command -v vim &> /dev/null; then
        echo "vim"
    elif command -v nano &> /dev/null; then
        echo "nano"
    else
        error_exit "No suitable editor found. Please set EDITOR environment variable or install code/vim/nano."
    fi
}

# Initialize git repo if needed
init_repo() {
    if [ ! -d "$JOURNAL_DIR/.git" ]; then
        warn_msg "Git repository not initialized in $JOURNAL_DIR"
        echo -n "Would you like to initialize it now? (y/n): "
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            git init
            echo "*.swp" > .gitignore
            echo ".DS_Store" >> .gitignore
            git add .gitignore
            git commit -m "Initial commit"
            success_msg "Git repository initialized!"
            warn_msg "Don't forget to add a remote: git remote add origin <your-repo-url>"
        else
            warn_msg "Continuing without git version control..."
            return 1
        fi
    fi
    return 0
}

# Show help
show_help() {
    cat << EOF
journalot - Minimal journaling CLI for developers

USAGE:
    journal [OPTIONS] ["quick capture text"]

OPTIONS:
    -h, --help              Show this help message
    -l, --list              List all journal entries with previews
    -y, --yesterday         Open yesterday's entry
    -d, --date DATE         Open entry for specific date (YYYY-MM-DD)
    -t, --time              Create timestamped entry (multiple per day)
    -s, --search QUERY      Search entries for keyword
    -w, --week              Open all entries from current week
    --tag TAG               Filter entries by tag
    --stats                 Show journal statistics
    --export FORMAT         Export entries (html/pdf)
    --random                Show a random entry
    --diff DATE             Show git diff for an entry
    --archive YEAR          Archive entries from a year
    --prompt                Show today's writing prompt

EXAMPLES:
    journal                           # Open today's journal
    journal "Had a great idea today"  # Quick capture (append without editor)
    journal --yesterday               # Open yesterday's journal
    journal --date 2025-01-15         # Open specific date
    journal --time                    # Create timestamped entry
    journal --search "confidence"     # Search all entries
    journal --week                    # Open this week's entries
    journal --tag work                # Filter by tag
    journal --stats                   # View statistics
    journal --export html             # Export to HTML

CONFIGURATION:
    Journal directory: $JOURNAL_DIR
    Config file: $CONFIG_FILE
    Editor: \$EDITOR (fallback: code > vim > nano)

    Config options (in $CONFIG_FILE):
      AUTOSYNC=true         # Skip commit/push prompts
EOF
}

# List all entries with details
list_entries() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found at $JOURNAL_DIR/entries"
    fi

    echo -e "${BLUE}Journal entries:${NC}\n"
    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        local filename=$(basename "$file")
        local wordcount=$(wc -w < "$file" | tr -d ' ')
        local preview=$(head -2 "$file" | tail -1 | cut -c1-60)

        if [ -z "$preview" ]; then
            preview="(empty)"
        fi

        printf "  %s " "$filename"
        printf "${YELLOW}(%s words)${NC}\n" "$wordcount"
        printf "    %s\n\n" "$preview"
    done
}

# Search entries
search_entries() {
    local query="$1"
    if [ -z "$query" ]; then
        error_exit "Search query required"
    fi

    echo -e "${BLUE}Searching for: ${NC}$query\n"
    grep -i -n -H "$query" "$JOURNAL_DIR/entries"/*.md 2>/dev/null | while IFS=: read -r file line content; do
        local filename=$(basename "$file")
        echo -e "${GREEN}$filename${NC}:${YELLOW}$line${NC}: $content"
    done
}

# Show stats
show_stats() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found"
    fi

    local total_entries=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f | wc -l | tr -d ' ')
    local total_words=$(cat "$JOURNAL_DIR/entries"/*.md 2>/dev/null | wc -w | tr -d ' ')
    local first_entry=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort | head -1 | xargs basename .md)

    echo -e "${BLUE}Journal Statistics${NC}\n"
    echo "  Total entries: $total_entries"
    echo "  First entry: $first_entry"
    echo "  Total words: $total_words"

    if [ "$total_entries" -gt 0 ]; then
        local avg_words=$((total_words / total_entries))
        echo "  Average words per entry: $avg_words"
    fi
}

# Open week view
open_week() {
    local today=$(date '+%Y-%m-%d')
    local week_start=$(date -v-Mon '+%Y-%m-%d' 2>/dev/null || date -d 'last monday' '+%Y-%m-%d' 2>/dev/null)

    echo -e "${BLUE}This week's entries:${NC}\n"

    local files_to_open=()
    for i in {0..6}; do
        local check_date=$(date -v${week_start} -v+${i}d '+%Y-%m-%d' 2>/dev/null || date -d "$week_start + $i days" '+%Y-%m-%d' 2>/dev/null)
        local filepath="$JOURNAL_DIR/entries/$check_date.md"
        if [ -f "$filepath" ]; then
            files_to_open+=("$filepath")
            echo "  - $check_date"
        fi
    done

    if [ ${#files_to_open[@]} -eq 0 ]; then
        echo "  No entries this week"
        return
    fi

    echo ""
    local editor_cmd=$(get_editor)
    $editor_cmd "${files_to_open[@]}"
}

# Filter by tag
filter_by_tag() {
    local tag="$1"
    if [ -z "$tag" ]; then
        error_exit "Tag required"
    fi

    echo -e "${BLUE}Entries tagged with: ${NC}#$tag\n"
    grep -l "#$tag" "$JOURNAL_DIR/entries"/*.md 2>/dev/null | while read -r file; do
        local filename=$(basename "$file")
        echo "  $filename"
    done
}

# Export to HTML
export_html() {
    local output_file="$JOURNAL_DIR/journal-export.html"

    echo -e "${BLUE}Exporting to HTML...${NC}"

    cat > "$output_file" << 'HTMLHEAD'
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Journal Export</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 40px auto; padding: 20px; }
        h1 { color: #333; }
        .entry { border-left: 3px solid #007AFF; padding-left: 20px; margin: 30px 0; }
        .date { color: #666; font-size: 14px; }
        .content { margin-top: 10px; line-height: 1.6; }
    </style>
</head>
<body>
    <h1>Journal Entries</h1>
HTMLHEAD

    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        local filename=$(basename "$file" .md)
        local content=$(cat "$file" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g' | sed 's/^# .*//' | sed 's/^$/<br>/')

        cat >> "$output_file" << HTMLENTRY
    <div class="entry">
        <div class="date">$filename</div>
        <div class="content">$content</div>
    </div>
HTMLENTRY
    done

    echo '</body></html>' >> "$output_file"

    success_msg "Exported to: $output_file"
}

# Export to PDF (requires pandoc)
export_pdf() {
    if ! command -v pandoc &> /dev/null; then
        error_exit "pandoc is required for PDF export. Install with: brew install pandoc"
    fi

    local temp_md="$JOURNAL_DIR/temp-export.md"
    local output_file="$JOURNAL_DIR/journal-export.pdf"

    echo -e "${BLUE}Exporting to PDF...${NC}"

    echo "# Journal Entries" > "$temp_md"
    echo "" >> "$temp_md"

    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        cat "$file" >> "$temp_md"
        echo "" >> "$temp_md"
        echo "---" >> "$temp_md"
        echo "" >> "$temp_md"
    done

    pandoc "$temp_md" -o "$output_file"
    rm "$temp_md"

    success_msg "Exported to: $output_file"
}

# Quick capture
quick_capture() {
    local text="$1"
    local timestamp=$(date '+%H:%M')
    local filename="$JOURNAL_DIR/entries/$ENTRY_DATE.md"

    mkdir -p "$JOURNAL_DIR/entries"

    if [ ! -f "$filename" ]; then
        echo "# $ENTRY_DATE" > "$filename"
        echo "" >> "$filename"
    fi

    echo "" >> "$filename"
    echo "**$timestamp** - $text" >> "$filename"

    success_msg "Added to $ENTRY_DATE.md"
}

# Random entry
show_random() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found"
    fi

    local files=($(find "$JOURNAL_DIR/entries" -name "*.md" -type f))

    if [ ${#files[@]} -eq 0 ]; then
        error_exit "No journal entries found"
    fi

    local random_index=$((RANDOM % ${#files[@]}))
    local random_file="${files[$random_index]}"
    local filename=$(basename "$random_file" .md)

    echo -e "${BLUE}Random entry: ${GREEN}$filename${NC}\n"
    cat "$random_file"
}

# Show diff for entry
show_diff() {
    local target_date="$1"
    if [ -z "$target_date" ]; then
        error_exit "Date required for --diff"
    fi

    local filename="$JOURNAL_DIR/entries/$target_date.md"

    if [ ! -f "$filename" ]; then
        error_exit "No entry found for $target_date"
    fi

    cd "$JOURNAL_DIR" || error_exit "Cannot access journal directory"

    echo -e "${BLUE}Changes to $target_date.md:${NC}\n"
    git log -p --color -- "entries/$target_date.md" | head -100
}

# Archive entries
archive_entries() {
    local year="$1"
    local unarchive="$2"

    if [ -z "$year" ]; then
        error_exit "Year required for --archive (e.g., --archive 2024)"
    fi

    if [ "$unarchive" = "--unarchive" ]; then
        # Restore from archive
        if [ ! -d "$JOURNAL_DIR/archive/$year" ]; then
            error_exit "No archive found for $year"
        fi

        echo -e "${BLUE}Restoring $year entries from archive...${NC}"
        mv "$JOURNAL_DIR/archive/$year"/*.md "$JOURNAL_DIR/entries/" 2>/dev/null
        rmdir "$JOURNAL_DIR/archive/$year" 2>/dev/null

        success_msg "Restored $year entries"
    else
        # Archive
        mkdir -p "$JOURNAL_DIR/archive/$year"

        local count=$(find "$JOURNAL_DIR/entries" -name "$year-*.md" -type f 2>/dev/null | wc -l | tr -d ' ')

        if [ "$count" -eq 0 ]; then
            error_exit "No entries found for $year"
        fi

        echo -e "${BLUE}Archiving $count entries from $year...${NC}"
        mv "$JOURNAL_DIR/entries/$year-"*.md "$JOURNAL_DIR/archive/$year/" 2>/dev/null

        success_msg "Archived $count entries to archive/$year/"
    fi
}

# Get daily prompt
get_daily_prompt() {
    local prompts=(
        "What made you smile today?"
        "What challenged you today?"
        "What are you grateful for right now?"
        "What did you learn today?"
        "What would you do differently?"
        "What progress did you make?"
        "What's on your mind?"
        "Who inspired you today?"
        "What surprised you?"
        "What are you looking forward to?"
        "What did you accomplish today?"
        "What's something you're proud of?"
        "What helped you grow today?"
        "What made today unique?"
        "What connections did you make?"
        "What decision are you facing?"
        "What pattern did you notice?"
        "What do you need to let go of?"
        "What energized you today?"
        "What drained your energy?"
    )

    # Use date as seed for consistent daily prompt
    local day_of_year=$(date '+%j')
    local index=$((day_of_year % ${#prompts[@]}))

    echo "${prompts[$index]}"
}

# Parse arguments
ENTRY_DATE=$(date '+%Y-%m-%d')
USE_TIMESTAMP=false
QUICK_CAPTURE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -l|--list)
            list_entries
            exit 0
            ;;
        -y|--yesterday)
            ENTRY_DATE=$(date -v-1d '+%Y-%m-%d' 2>/dev/null || date -d 'yesterday' '+%Y-%m-%d' 2>/dev/null)
            shift
            ;;
        -d|--date)
            if [ -z "$2" ]; then
                error_exit "Date argument required for --date flag"
            fi
            ENTRY_DATE="$2"
            shift 2
            ;;
        -t|--time)
            USE_TIMESTAMP=true
            shift
            ;;
        -s|--search)
            if [ -z "$2" ]; then
                error_exit "Search query required"
            fi
            search_entries "$2"
            exit 0
            ;;
        -w|--week)
            open_week
            exit 0
            ;;
        --tag)
            if [ -z "$2" ]; then
                error_exit "Tag required"
            fi
            filter_by_tag "$2"
            exit 0
            ;;
        --stats)
            show_stats
            exit 0
            ;;
        --export)
            if [ -z "$2" ]; then
                error_exit "Export format required (html/pdf)"
            fi
            if [ "$2" = "html" ]; then
                export_html
            elif [ "$2" = "pdf" ]; then
                export_pdf
            else
                error_exit "Unknown export format: $2 (use html or pdf)"
            fi
            exit 0
            ;;
        --random)
            show_random
            exit 0
            ;;
        --diff)
            if [ -z "$2" ]; then
                error_exit "Date required for --diff"
            fi
            show_diff "$2"
            exit 0
            ;;
        --archive)
            if [ -z "$2" ]; then
                error_exit "Year required for --archive"
            fi
            archive_entries "$2" "$3"
            exit 0
            ;;
        --prompt)
            get_daily_prompt
            exit 0
            ;;
        -*)
            error_exit "Unknown option: $1\nUse --help for usage information"
            ;;
        *)
            # Treat as quick capture text
            QUICK_CAPTURE="$1"
            shift
            ;;
    esac
done

# Handle quick capture
if [ -n "$QUICK_CAPTURE" ]; then
    quick_capture "$QUICK_CAPTURE"
    exit 0
fi

# Main logic
check_dependencies

# Handle timestamped entries
if [ "$USE_TIMESTAMP" = true ]; then
    TIMESTAMP=$(date '+%H%M')
    FILENAME="$JOURNAL_DIR/entries/$ENTRY_DATE-$TIMESTAMP.md"
else
    FILENAME="$JOURNAL_DIR/entries/$ENTRY_DATE.md"
fi

EDITOR_CMD=$(get_editor)

mkdir -p "$JOURNAL_DIR/entries"
cd "$JOURNAL_DIR" || error_exit "Cannot access journal directory: $JOURNAL_DIR"

# Initialize or check git repo
USE_GIT=true
init_repo || USE_GIT=false

# Pull latest changes if git is available
if [ "$USE_GIT" = true ] && git remote get-url origin &> /dev/null; then
    echo "Syncing with remote..."
    if ! git pull origin main --rebase 2>/dev/null; then
        warn_msg "Failed to pull from remote. Continuing with local changes..."
    fi
fi

# Create entry if it doesn't exist
if [ ! -f "$FILENAME" ]; then
    # Check for template
    if [ -f "$JOURNAL_DIR/template.md" ]; then
        cat "$JOURNAL_DIR/template.md" > "$FILENAME"
        # Replace {{date}} placeholder if it exists
        sed -i.bak "s/{{date}}/$ENTRY_DATE/g" "$FILENAME" && rm "${FILENAME}.bak"
    else
        echo "# $ENTRY_DATE" > "$FILENAME"
        echo "" >> "$FILENAME"

        # Add daily prompt if not disabled
        if [ "$DISABLE_PROMPTS" != "true" ]; then
            local prompt=$(get_daily_prompt)
            echo "**Prompt**: $prompt" >> "$FILENAME"
            echo "" >> "$FILENAME"
        fi
    fi

    if [ "$USE_TIMESTAMP" = true ]; then
        success_msg "Created new entry: $ENTRY_DATE-$TIMESTAMP.md"
    else
        success_msg "Created new entry: $ENTRY_DATE.md"
    fi
else
    if [ "$USE_TIMESTAMP" = true ]; then
        echo "Opening existing entry: $ENTRY_DATE-$TIMESTAMP.md"
    else
        echo "Opening existing entry: $ENTRY_DATE.md"
    fi
fi

# Get file hash before editing (to detect changes)
BEFORE_HASH=$(md5sum "$FILENAME" 2>/dev/null || md5 -q "$FILENAME" 2>/dev/null)

# Open in editor
$EDITOR_CMD "$FILENAME"

# Only commit if git is enabled and file was modified
if [ "$USE_GIT" = true ]; then
    AFTER_HASH=$(md5sum "$FILENAME" 2>/dev/null || md5 -q "$FILENAME" 2>/dev/null)

    if [ "$BEFORE_HASH" != "$AFTER_HASH" ]; then
        echo ""

        # Auto-sync if configured
        if [ "$AUTOSYNC" = "true" ]; then
            git add "$FILENAME"
            git commit -m "Journal entry for $ENTRY_DATE"

            if git remote get-url origin &> /dev/null; then
                if git push origin main; then
                    success_msg "✅ Changes auto-committed and pushed!"
                else
                    warn_msg "Failed to push. Run 'git push' manually when ready."
                fi
            else
                success_msg "✅ Changes auto-committed locally"
            fi
        else
            echo -n "Commit changes? (y/n): "
            read -r commit_response

            if [[ "$commit_response" =~ ^[Yy]$ ]]; then
                git add "$FILENAME"
                git commit -m "Journal entry for $ENTRY_DATE"

                if git remote get-url origin &> /dev/null; then
                    echo -n "Push to remote? (y/n): "
                    read -r push_response

                    if [[ "$push_response" =~ ^[Yy]$ ]]; then
                        if git push origin main; then
                            success_msg "✅ Changes committed and pushed!"
                        else
                            warn_msg "Failed to push. Run 'git push' manually when ready."
                        fi
                    else
                        success_msg "✅ Changes committed locally"
                    fi
                else
                    success_msg "✅ Changes committed locally"
                fi
            fi
        fi
    else
        echo "No changes detected."
    fi
fi
