#!/bin/bash

set -e

JOURNAL_DIR="$HOME/journalot"
CONFIG_FILE="$HOME/.journalotrc"

# Load config if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Error handling
error_exit() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success_msg() {
    echo -e "${GREEN}$1${NC}"
}

warn_msg() {
    echo -e "${YELLOW}$1${NC}"
}

# Check dependencies
check_dependencies() {
    if ! command -v git &> /dev/null; then
        error_exit "git is not installed. Please install git first."
    fi
}

# Determine editor
get_editor() {
    if [ -n "$EDITOR" ]; then
        echo "$EDITOR"
    elif command -v code &> /dev/null; then
        echo "code"
    elif command -v vim &> /dev/null; then
        echo "vim"
    elif command -v nano &> /dev/null; then
        echo "nano"
    else
        error_exit "No suitable editor found. Please set EDITOR environment variable or install code/vim/nano."
    fi
}

# Initialize git repo if needed
init_repo() {
    if [ ! -d "$JOURNAL_DIR/.git" ]; then
        warn_msg "Git repository not initialized in $JOURNAL_DIR"
        echo -n "Would you like to initialize it now? (y/n): "
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            git init
            echo "*.swp" > .gitignore
            echo ".DS_Store" >> .gitignore
            git add .gitignore
            git commit -m "Initial commit"
            success_msg "Git repository initialized!"
            warn_msg "Don't forget to add a remote: git remote add origin <your-repo-url>"
        else
            warn_msg "Continuing without git version control..."
            return 1
        fi
    fi
    return 0
}

# Show help
show_help() {
    cat << EOF
journalot - Minimal journaling CLI for developers

USAGE:
    journal [OPTIONS] ["quick capture text"]

OPTIONS:
    -h, --help              Show this help message
    -l, --list              List all journal entries with previews
    -y, --yesterday         Open yesterday's entry
    -d, --date DATE         Open entry for specific date (YYYY-MM-DD)
    -t, --time              Create timestamped entry (multiple per day)
    -s, --search QUERY      Search entries for keyword
    -w, --week              Open all entries from current week
    --tag TAG               Filter entries by tag
    --stats                 Show journal statistics
    --export FORMAT         Export entries (html/pdf)

EXAMPLES:
    journal                           # Open today's journal
    journal "Had a great idea today"  # Quick capture (append without editor)
    journal --yesterday               # Open yesterday's journal
    journal --date 2025-01-15         # Open specific date
    journal --time                    # Create timestamped entry
    journal --search "confidence"     # Search all entries
    journal --week                    # Open this week's entries
    journal --tag work                # Filter by tag
    journal --stats                   # View statistics
    journal --export html             # Export to HTML

CONFIGURATION:
    Journal directory: $JOURNAL_DIR
    Config file: $CONFIG_FILE
    Editor: \$EDITOR (fallback: code > vim > nano)

    Config options (in $CONFIG_FILE):
      AUTOSYNC=true         # Skip commit/push prompts
EOF
}

# List all entries with details
list_entries() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found at $JOURNAL_DIR/entries"
    fi

    echo -e "${BLUE}Journal entries:${NC}\n"
    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        local filename=$(basename "$file")
        local wordcount=$(wc -w < "$file" | tr -d ' ')
        local preview=$(head -2 "$file" | tail -1 | cut -c1-60)

        if [ -z "$preview" ]; then
            preview="(empty)"
        fi

        printf "  %s " "$filename"
        printf "${YELLOW}(%s words)${NC}\n" "$wordcount"
        printf "    %s\n\n" "$preview"
    done
}

# Search entries
search_entries() {
    local query="$1"
    if [ -z "$query" ]; then
        error_exit "Search query required"
    fi

    echo -e "${BLUE}Searching for: ${NC}$query\n"
    grep -i -n -H "$query" "$JOURNAL_DIR/entries"/*.md 2>/dev/null | while IFS=: read -r file line content; do
        local filename=$(basename "$file")
        echo -e "${GREEN}$filename${NC}:${YELLOW}$line${NC}: $content"
    done
}

# Show stats
show_stats() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found"
    fi

    local total_entries=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f | wc -l | tr -d ' ')
    local total_words=$(cat "$JOURNAL_DIR/entries"/*.md 2>/dev/null | wc -w | tr -d ' ')
    local first_entry=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort | head -1 | xargs basename .md)

    echo -e "${BLUE}Journal Statistics${NC}\n"
    echo "  Total entries: $total_entries"
    echo "  First entry: $first_entry"
    echo "  Total words: $total_words"

    if [ "$total_entries" -gt 0 ]; then
        local avg_words=$((total_words / total_entries))
        echo "  Average words per entry: $avg_words"
    fi
}

# Open week view
open_week() {
    local today=$(date '+%Y-%m-%d')
    local week_start=$(date -v-Mon '+%Y-%m-%d' 2>/dev/null || date -d 'last monday' '+%Y-%m-%d' 2>/dev/null)

    echo -e "${BLUE}This week's entries:${NC}\n"

    local files_to_open=()
    for i in {0..6}; do
        local check_date=$(date -v${week_start} -v+${i}d '+%Y-%m-%d' 2>/dev/null || date -d "$week_start + $i days" '+%Y-%m-%d' 2>/dev/null)
        local filepath="$JOURNAL_DIR/entries/$check_date.md"
        if [ -f "$filepath" ]; then
            files_to_open+=("$filepath")
            echo "  - $check_date"
        fi
    done

    if [ ${#files_to_open[@]} -eq 0 ]; then
        echo "  No entries this week"
        return
    fi

    echo ""
    local editor_cmd=$(get_editor)
    $editor_cmd "${files_to_open[@]}"
}

# Filter by tag
filter_by_tag() {
    local tag="$1"
    if [ -z "$tag" ]; then
        error_exit "Tag required"
    fi

    echo -e "${BLUE}Entries tagged with: ${NC}#$tag\n"
    grep -l "#$tag" "$JOURNAL_DIR/entries"/*.md 2>/dev/null | while read -r file; do
        local filename=$(basename "$file")
        echo "  $filename"
    done
}

# Export to HTML
export_html() {
    local output_file="$JOURNAL_DIR/journal-export.html"

    echo -e "${BLUE}Exporting to HTML...${NC}"

    cat > "$output_file" << 'HTMLHEAD'
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Journal Export</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 40px auto; padding: 20px; }
        h1 { color: #333; }
        .entry { border-left: 3px solid #007AFF; padding-left: 20px; margin: 30px 0; }
        .date { color: #666; font-size: 14px; }
        .content { margin-top: 10px; line-height: 1.6; }
    </style>
</head>
<body>
    <h1>Journal Entries</h1>
HTMLHEAD

    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        local filename=$(basename "$file" .md)
        local content=$(cat "$file" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g' | sed 's/^# .*//' | sed 's/^$/<br>/')

        cat >> "$output_file" << HTMLENTRY
    <div class="entry">
        <div class="date">$filename</div>
        <div class="content">$content</div>
    </div>
HTMLENTRY
    done

    echo '</body></html>' >> "$output_file"

    success_msg "Exported to: $output_file"
}

# Export to PDF (requires pandoc)
export_pdf() {
    if ! command -v pandoc &> /dev/null; then
        error_exit "pandoc is required for PDF export. Install with: brew install pandoc"
    fi

    local temp_md="$JOURNAL_DIR/temp-export.md"
    local output_file="$JOURNAL_DIR/journal-export.pdf"

    echo -e "${BLUE}Exporting to PDF...${NC}"

    echo "# Journal Entries" > "$temp_md"
    echo "" >> "$temp_md"

    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        cat "$file" >> "$temp_md"
        echo "" >> "$temp_md"
        echo "---" >> "$temp_md"
        echo "" >> "$temp_md"
    done

    pandoc "$temp_md" -o "$output_file"
    rm "$temp_md"

    success_msg "Exported to: $output_file"
}

# Quick capture
quick_capture() {
    local text="$1"
    local timestamp=$(date '+%H:%M')
    local filename="$JOURNAL_DIR/entries/$ENTRY_DATE.md"

    mkdir -p "$JOURNAL_DIR/entries"

    if [ ! -f "$filename" ]; then
        echo "# $ENTRY_DATE" > "$filename"
        echo "" >> "$filename"
    fi

    echo "" >> "$filename"
    echo "**$timestamp** - $text" >> "$filename"

    success_msg "Added to $ENTRY_DATE.md"
}

# Parse arguments
ENTRY_DATE=$(date '+%Y-%m-%d')
USE_TIMESTAMP=false
QUICK_CAPTURE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -l|--list)
            list_entries
            exit 0
            ;;
        -y|--yesterday)
            ENTRY_DATE=$(date -v-1d '+%Y-%m-%d' 2>/dev/null || date -d 'yesterday' '+%Y-%m-%d' 2>/dev/null)
            shift
            ;;
        -d|--date)
            if [ -z "$2" ]; then
                error_exit "Date argument required for --date flag"
            fi
            ENTRY_DATE="$2"
            shift 2
            ;;
        -t|--time)
            USE_TIMESTAMP=true
            shift
            ;;
        -s|--search)
            if [ -z "$2" ]; then
                error_exit "Search query required"
            fi
            search_entries "$2"
            exit 0
            ;;
        -w|--week)
            open_week
            exit 0
            ;;
        --tag)
            if [ -z "$2" ]; then
                error_exit "Tag required"
            fi
            filter_by_tag "$2"
            exit 0
            ;;
        --stats)
            show_stats
            exit 0
            ;;
        --export)
            if [ -z "$2" ]; then
                error_exit "Export format required (html/pdf)"
            fi
            if [ "$2" = "html" ]; then
                export_html
            elif [ "$2" = "pdf" ]; then
                export_pdf
            else
                error_exit "Unknown export format: $2 (use html or pdf)"
            fi
            exit 0
            ;;
        -*)
            error_exit "Unknown option: $1\nUse --help for usage information"
            ;;
        *)
            # Treat as quick capture text
            QUICK_CAPTURE="$1"
            shift
            ;;
    esac
done

# Handle quick capture
if [ -n "$QUICK_CAPTURE" ]; then
    quick_capture "$QUICK_CAPTURE"
    exit 0
fi

# Main logic
check_dependencies

# Handle timestamped entries
if [ "$USE_TIMESTAMP" = true ]; then
    TIMESTAMP=$(date '+%H%M')
    FILENAME="$JOURNAL_DIR/entries/$ENTRY_DATE-$TIMESTAMP.md"
else
    FILENAME="$JOURNAL_DIR/entries/$ENTRY_DATE.md"
fi

EDITOR_CMD=$(get_editor)

mkdir -p "$JOURNAL_DIR/entries"
cd "$JOURNAL_DIR" || error_exit "Cannot access journal directory: $JOURNAL_DIR"

# Initialize or check git repo
USE_GIT=true
init_repo || USE_GIT=false

# Pull latest changes if git is available
if [ "$USE_GIT" = true ] && git remote get-url origin &> /dev/null; then
    echo "Syncing with remote..."
    if ! git pull origin main --rebase 2>/dev/null; then
        warn_msg "Failed to pull from remote. Continuing with local changes..."
    fi
fi

# Create entry if it doesn't exist
if [ ! -f "$FILENAME" ]; then
    # Check for template
    if [ -f "$JOURNAL_DIR/template.md" ]; then
        cat "$JOURNAL_DIR/template.md" > "$FILENAME"
        # Replace {{date}} placeholder if it exists
        sed -i.bak "s/{{date}}/$ENTRY_DATE/g" "$FILENAME" && rm "${FILENAME}.bak"
    else
        echo "# $ENTRY_DATE" > "$FILENAME"
        echo "" >> "$FILENAME"
    fi

    if [ "$USE_TIMESTAMP" = true ]; then
        success_msg "Created new entry: $ENTRY_DATE-$TIMESTAMP.md"
    else
        success_msg "Created new entry: $ENTRY_DATE.md"
    fi
else
    if [ "$USE_TIMESTAMP" = true ]; then
        echo "Opening existing entry: $ENTRY_DATE-$TIMESTAMP.md"
    else
        echo "Opening existing entry: $ENTRY_DATE.md"
    fi
fi

# Get file hash before editing (to detect changes)
BEFORE_HASH=$(md5sum "$FILENAME" 2>/dev/null || md5 -q "$FILENAME" 2>/dev/null)

# Open in editor
$EDITOR_CMD "$FILENAME"

# Only commit if git is enabled and file was modified
if [ "$USE_GIT" = true ]; then
    AFTER_HASH=$(md5sum "$FILENAME" 2>/dev/null || md5 -q "$FILENAME" 2>/dev/null)

    if [ "$BEFORE_HASH" != "$AFTER_HASH" ]; then
        echo ""

        # Auto-sync if configured
        if [ "$AUTOSYNC" = "true" ]; then
            git add "$FILENAME"
            git commit -m "Journal entry for $ENTRY_DATE"

            if git remote get-url origin &> /dev/null; then
                if git push origin main; then
                    success_msg "✅ Changes auto-committed and pushed!"
                else
                    warn_msg "Failed to push. Run 'git push' manually when ready."
                fi
            else
                success_msg "✅ Changes auto-committed locally"
            fi
        else
            echo -n "Commit changes? (y/n): "
            read -r commit_response

            if [[ "$commit_response" =~ ^[Yy]$ ]]; then
                git add "$FILENAME"
                git commit -m "Journal entry for $ENTRY_DATE"

                if git remote get-url origin &> /dev/null; then
                    echo -n "Push to remote? (y/n): "
                    read -r push_response

                    if [[ "$push_response" =~ ^[Yy]$ ]]; then
                        if git push origin main; then
                            success_msg "✅ Changes committed and pushed!"
                        else
                            warn_msg "Failed to push. Run 'git push' manually when ready."
                        fi
                    else
                        success_msg "✅ Changes committed locally"
                    fi
                else
                    success_msg "✅ Changes committed locally"
                fi
            fi
        fi
    else
        echo "No changes detected."
    fi
fi
