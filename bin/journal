#!/usr/bin/env bash

set -e

JOURNAL_DIR="${JOURNAL_DIR:-$HOME/journalot}"

# XDG Base Directory support
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
CONFIG_DIR="$XDG_CONFIG_HOME/journalot"
CONFIG_FILE="$CONFIG_DIR/config"

# Migrate old config if it exists
OLD_CONFIG="$HOME/.journalotrc"
if [ -f "$OLD_CONFIG" ] && [ ! -f "$CONFIG_FILE" ]; then
    mkdir -p "$CONFIG_DIR"
    mv "$OLD_CONFIG" "$CONFIG_FILE"
    echo -e "\033[1;33mMigrated config from ~/.journalotrc to $CONFIG_FILE\033[0m"
fi

# Load config if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Default git branch (can be overridden in config)
GIT_BRANCH="${GIT_BRANCH:-main}"

# Color codes for output using tput (falls back to ANSI if tput unavailable)
if command -v tput &> /dev/null && tput setaf 1 &> /dev/null; then
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput bold; tput setaf 3)
    BLUE=$(tput setaf 4)
    NC=$(tput sgr0)
else
    # Fallback to ANSI escape codes
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
fi

# Error handling
error_exit() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success_msg() {
    echo -e "${GREEN}$1${NC}"
}

warn_msg() {
    echo -e "${YELLOW}$1${NC}"
}

# Check dependencies
check_dependencies() {
    if ! command -v git &> /dev/null; then
        error_exit "git is not installed. Please install git first."
    fi
}

# Parse natural language dates
parse_date() {
    local input="$1"

    # Try to parse as natural language using date command
    # Linux uses -d, macOS uses -j -f for parsing but we'll use a simpler approach
    local parsed_date

    # Try Linux date first
    parsed_date=$(date -d "$input" '+%Y-%m-%d' 2>/dev/null)

    # If that fails, try macOS date with common patterns
    if [ -z "$parsed_date" ]; then
        case "$input" in
            "yesterday")
                parsed_date=$(date -v-1d '+%Y-%m-%d' 2>/dev/null)
                ;;
            "tomorrow")
                parsed_date=$(date -v+1d '+%Y-%m-%d' 2>/dev/null)
                ;;
            *"days ago")
                local days=$(echo "$input" | grep -o '[0-9]*')
                parsed_date=$(date -v-${days}d '+%Y-%m-%d' 2>/dev/null)
                ;;
            *"weeks ago")
                local weeks=$(echo "$input" | grep -o '[0-9]*')
                local days=$((weeks * 7))
                parsed_date=$(date -v-${days}d '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last week")
                parsed_date=$(date -v-7d '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last monday"|"last Monday")
                parsed_date=$(date -v-Mon -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last tuesday"|"last Tuesday")
                parsed_date=$(date -v-Tue -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last wednesday"|"last Wednesday")
                parsed_date=$(date -v-Wed -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last thursday"|"last Thursday")
                parsed_date=$(date -v-Thu -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last friday"|"last Friday")
                parsed_date=$(date -v-Fri -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last saturday"|"last Saturday")
                parsed_date=$(date -v-Sat -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            "last sunday"|"last Sunday")
                parsed_date=$(date -v-Sun -v-1w '+%Y-%m-%d' 2>/dev/null)
                ;;
            *)
                # If still nothing, assume it's a regular date format
                parsed_date="$input"
                ;;
        esac
    fi

    echo "$parsed_date"
}

# Determine editor
get_editor() {
    if [ -n "$EDITOR" ]; then
        echo "$EDITOR"
    elif command -v code &> /dev/null; then
        echo "code"
    elif command -v vim &> /dev/null; then
        echo "vim"
    elif command -v nano &> /dev/null; then
        echo "nano"
    else
        error_exit "No suitable editor found. Please set EDITOR environment variable or install code/vim/nano."
    fi
}

# Initialize git repo if needed
init_repo() {
    if [ ! -d "$JOURNAL_DIR/.git" ]; then
        warn_msg "Git repository not initialized in $JOURNAL_DIR"
        echo -n "Would you like to initialize it now? (y/n): "
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            git init
            echo "*.swp" > .gitignore
            echo ".DS_Store" >> .gitignore
            git add .gitignore
            git commit -m "Initial commit"
            success_msg "Git repository initialized!"
            warn_msg "Don't forget to add a remote: git remote add origin <your-repo-url>"
        else
            warn_msg "Continuing without git version control..."
            return 1
        fi
    fi
    return 0
}

# Show help
show_help() {
    cat << EOF
journalot - Minimal journaling CLI for developers

USAGE:
    journal [OPTIONS] ["quick capture text"]

OPTIONS:
    -h, --help              Show this help message
    -l, --list              List all journal entries with previews (newest first)
        --oldest-first      List entries oldest first (use with --list)
    -y, --yesterday         Open yesterday's entry
    -d, --date DATE         Open entry for specific date (YYYY-MM-DD)
    -t, --time              Create timestamped entry (multiple per day)
    -s, --search QUERY      Search entries for keyword
    -w, --week              Open all entries from current week
    --tag TAG               Filter entries by tag
    --stats                 Show journal statistics
    --export FORMAT         Export entries (html/pdf)
    --random                Show a random entry
    --diff DATE             Show git diff for an entry
    --archive YEAR          Archive entries from a year
    --prompt                Show today's writing prompt
    --backup                Create a backup of all journal entries
    --restore               Restore journal from a backup

EXAMPLES:
    journal                                # Open today's journal
    journal "Had a great idea today"       # Quick capture (append without editor)
    journal --list                         # List entries (newest first)
    journal --list --oldest-first          # List entries (oldest first)
    journal --yesterday                    # Open yesterday's journal
    journal --date 2025-01-15         # Open specific date
    journal --date "last friday"      # Natural language dates
    journal --date "3 days ago"       # Relative dates
    journal --time                    # Create timestamped entry
    journal --search "confidence"     # Search all entries
    journal --week                    # Open this week's entries
    journal --tag work                # Filter by tag
    journal --stats                   # View statistics
    journal --export html             # Export to HTML

CONFIGURATION:
    Journal directory: $JOURNAL_DIR
    Config file: $CONFIG_FILE
    Editor: \$EDITOR (fallback: code > vim > nano)

    Config options (in $CONFIG_FILE):
      AUTOSYNC=true              # Skip commit/push prompts
      DISABLE_PROMPTS=true       # Disable daily writing prompts
      GIT_BRANCH=main            # Git branch name (default: main)
EOF
}

# List all entries with details
list_entries() {
    local sort_order="$1"
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found at $JOURNAL_DIR/entries\n\nTo create your first entry, run:\n  journal"
    fi

    echo -e "${BLUE}Journal entries:${NC}\n"

    if [ "$sort_order" = "oldest-first" ]; then
        find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort | while read -r file; do
            local filename=$(basename "$file")
            local wordcount=$(wc -w < "$file" | tr -d ' ')
            local preview=$(head -2 "$file" | tail -1 | cut -c1-60)

            if [ -z "$preview" ]; then
                preview="(empty)"
            fi

            printf "  %s " "$filename"
            printf "${YELLOW}(%s words)${NC}\n" "$wordcount"
            printf "    %s\n\n" "$preview"
        done
    else
        find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
            local filename=$(basename "$file")
            local wordcount=$(wc -w < "$file" | tr -d ' ')
            local preview=$(head -2 "$file" | tail -1 | cut -c1-60)

            if [ -z "$preview" ]; then
                preview="(empty)"
            fi

            printf "  %s " "$filename"
            printf "${YELLOW}(%s words)${NC}\n" "$wordcount"
            printf "    %s\n\n" "$preview"
        done
    fi
}

# Search entries
search_entries() {
    local query="$1"
    if [ -z "$query" ]; then
        error_exit "Search query required"
    fi

    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found\n\nTo create your first entry, run:\n  journal"
    fi

    echo -e "${BLUE}Searching for: ${NC}$query\n"

    # Use grep with context lines and color highlighting
    # -i: case insensitive, -n: line numbers, -H: filename, -A2 -B2: 2 lines before/after
    local matches=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f -exec grep -l -i "$query" {} \; 2>/dev/null)

    if [ -z "$matches" ]; then
        echo -e "${YELLOW}No matches found${NC}"
        return
    fi

    # Show matches with context
    find "$JOURNAL_DIR/entries" -name "*.md" -type f -exec grep -H -n -i -A 2 -B 2 --color=always "$query" {} \; 2>/dev/null

    # Show count
    local count=$(echo "$matches" | wc -l | tr -d ' ')
    echo -e "\n${BLUE}Found in $count entries${NC}"
}

# Show stats
show_stats() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found\n\nTo create your first entry, run:\n  journal"
    fi

    local total_entries=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f | wc -l | tr -d ' ')
    local total_words=$(cat "$JOURNAL_DIR/entries"/*.md 2>/dev/null | wc -w | tr -d ' ')
    local first_entry=$(find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort | head -1 | xargs basename .md)

    echo -e "${BLUE}Journal Statistics${NC}\n"
    echo "  Total entries: $total_entries"
    echo "  First entry: $first_entry"
    echo "  Total words: $total_words"

    if [ "$total_entries" -gt 0 ]; then
        local avg_words=$((total_words / total_entries))
        echo "  Average words per entry: $avg_words"
    fi
}

# Open week view
open_week() {
    local today=$(date '+%Y-%m-%d')
    local week_start=$(date -v-Mon '+%Y-%m-%d' 2>/dev/null || date -d 'last monday' '+%Y-%m-%d' 2>/dev/null)

    echo -e "${BLUE}This week's entries:${NC}\n"

    local files_to_open=()
    for i in {0..6}; do
        local check_date=$(date -v${week_start} -v+${i}d '+%Y-%m-%d' 2>/dev/null || date -d "$week_start + $i days" '+%Y-%m-%d' 2>/dev/null)
        local filepath="$JOURNAL_DIR/entries/$check_date.md"
        if [ -f "$filepath" ]; then
            files_to_open+=("$filepath")
            echo "  - $check_date"
        fi
    done

    if [ ${#files_to_open[@]} -eq 0 ]; then
        echo "  No entries this week"
        return
    fi

    echo ""
    local editor_cmd=$(get_editor)
    $editor_cmd "${files_to_open[@]}"
}

# Filter by tag
filter_by_tag() {
    local tag="$1"
    if [ -z "$tag" ]; then
        error_exit "Tag required"
    fi

    echo -e "${BLUE}Entries tagged with: ${NC}#$tag\n"
    grep -l "#$tag" "$JOURNAL_DIR/entries"/*.md 2>/dev/null | while read -r file; do
        local filename=$(basename "$file")
        echo "  $filename"
    done
}

# Export to HTML
export_html() {
    local output_file="$JOURNAL_DIR/journal-export.html"

    echo -e "${BLUE}Exporting to HTML...${NC}"

    cat > "$output_file" << 'HTMLHEAD'
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Journal Export</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 40px auto; padding: 20px; }
        h1 { color: #333; }
        .entry { border-left: 3px solid #007AFF; padding-left: 20px; margin: 30px 0; }
        .date { color: #666; font-size: 14px; }
        .content { margin-top: 10px; line-height: 1.6; }
    </style>
</head>
<body>
    <h1>Journal Entries</h1>
HTMLHEAD

    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        local filename=$(basename "$file" .md)
        local content=$(cat "$file" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g' | sed 's/^# .*//' | sed 's/^$/<br>/')

        cat >> "$output_file" << HTMLENTRY
    <div class="entry">
        <div class="date">$filename</div>
        <div class="content">$content</div>
    </div>
HTMLENTRY
    done

    echo '</body></html>' >> "$output_file"

    success_msg "Exported to: $output_file"
}

# Export to PDF (requires pandoc)
export_pdf() {
    if ! command -v pandoc &> /dev/null; then
        error_exit "pandoc is required for PDF export. Install with: brew install pandoc"
    fi

    local temp_md="$JOURNAL_DIR/temp-export.md"
    local output_file="$JOURNAL_DIR/journal-export.pdf"

    echo -e "${BLUE}Exporting to PDF...${NC}"

    echo "# Journal Entries" > "$temp_md"
    echo "" >> "$temp_md"

    find "$JOURNAL_DIR/entries" -name "*.md" -type f | sort -r | while read -r file; do
        cat "$file" >> "$temp_md"
        echo "" >> "$temp_md"
        echo "---" >> "$temp_md"
        echo "" >> "$temp_md"
    done

    pandoc "$temp_md" -o "$output_file"
    rm "$temp_md"

    success_msg "Exported to: $output_file"
}

# Quick capture
quick_capture() {
    local text="$1"
    local timestamp=$(date '+%H:%M')
    local filename="$JOURNAL_DIR/entries/$ENTRY_DATE.md"

    mkdir -p "$JOURNAL_DIR/entries"

    if [ ! -f "$filename" ]; then
        echo "# $ENTRY_DATE" > "$filename"
        echo "" >> "$filename"
    fi

    echo "" >> "$filename"
    echo "**$timestamp** - $text" >> "$filename"

    success_msg "Added to $ENTRY_DATE.md"
}

# Random entry
show_random() {
    if [ ! -d "$JOURNAL_DIR/entries" ]; then
        error_exit "No entries directory found\n\nTo create your first entry, run:\n  journal"
    fi

    local files=($(find "$JOURNAL_DIR/entries" -name "*.md" -type f))

    if [ ${#files[@]} -eq 0 ]; then
        error_exit "No journal entries found\n\nTo create your first entry, run:\n  journal"
    fi

    local random_index=$((RANDOM % ${#files[@]}))
    local random_file="${files[$random_index]}"
    local filename=$(basename "$random_file" .md)

    echo -e "${BLUE}Random entry: ${GREEN}$filename${NC}\n"
    cat "$random_file"
}

# Show diff for entry
show_diff() {
    local target_date="$1"
    if [ -z "$target_date" ]; then
        error_exit "Date required for --diff"
    fi

    local filename="$JOURNAL_DIR/entries/$target_date.md"

    if [ ! -f "$filename" ]; then
        error_exit "No entry found for $target_date\n\nTo create an entry for this date, run:\n  journal --date $target_date"
    fi

    cd "$JOURNAL_DIR" || error_exit "Cannot access journal directory"

    echo -e "${BLUE}Changes to $target_date.md:${NC}\n"
    git log -p --color -- "entries/$target_date.md" | head -100
}

# Archive entries
archive_entries() {
    local year="$1"
    local unarchive="$2"

    if [ -z "$year" ]; then
        error_exit "Year required for --archive (e.g., --archive 2024)"
    fi

    if [ "$unarchive" = "--unarchive" ]; then
        # Restore from archive
        if [ ! -d "$JOURNAL_DIR/archive/$year" ]; then
            error_exit "No archive found for $year\n\nTo see available archives, run:\n  ls $JOURNAL_DIR/archive/"
        fi

        echo -e "${BLUE}Restoring $year entries from archive...${NC}"
        mv "$JOURNAL_DIR/archive/$year"/*.md "$JOURNAL_DIR/entries/" 2>/dev/null
        rmdir "$JOURNAL_DIR/archive/$year" 2>/dev/null

        success_msg "Restored $year entries"
    else
        # Archive
        mkdir -p "$JOURNAL_DIR/archive/$year"

        local count=$(find "$JOURNAL_DIR/entries" -name "$year-*.md" -type f 2>/dev/null | wc -l | tr -d ' ')

        if [ "$count" -eq 0 ]; then
            error_exit "No entries found for $year\n\nTo see all entries, run:\n  journal --list"
        fi

        echo -e "${BLUE}Archiving $count entries from $year...${NC}"
        mv "$JOURNAL_DIR/entries/$year-"*.md "$JOURNAL_DIR/archive/$year/" 2>/dev/null

        success_msg "Archived $count entries to archive/$year/"
    fi
}

# Backup journal
backup_journal() {
    local backup_dir="$JOURNAL_DIR/backups"
    local timestamp=$(date '+%Y%m%d-%H%M%S')
    local backup_file="$backup_dir/journal-backup-$timestamp.tar.gz"

    mkdir -p "$backup_dir"

    echo -e "${BLUE}Creating backup...${NC}"

    # Create compressed archive of entries
    if tar -czf "$backup_file" -C "$JOURNAL_DIR" entries 2>/dev/null; then
        local size=$(du -h "$backup_file" | cut -f1)
        success_msg "✅ Backup created: journal-backup-$timestamp.tar.gz ($size)"
        echo "   Location: $backup_file"
    else
        error_exit "Failed to create backup"
    fi
}

# Restore journal from backup
restore_journal() {
    local backup_dir="$JOURNAL_DIR/backups"

    if [ ! -d "$backup_dir" ]; then
        error_exit "No backups directory found\n\nTo create a backup, run:\n  journal --backup"
    fi

    echo -e "${BLUE}Available backups:${NC}\n"

    local backups=($(ls -t "$backup_dir"/journal-backup-*.tar.gz 2>/dev/null))

    if [ ${#backups[@]} -eq 0 ]; then
        error_exit "No backups found\n\nTo create a backup, run:\n  journal --backup"
    fi

    local i=1
    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local size=$(du -h "$backup" | cut -f1)
        local date=$(echo "$filename" | sed 's/journal-backup-\(.*\)\.tar\.gz/\1/' | sed 's/\([0-9]\{8\}\)-\([0-9]\{6\}\)/\1 \2/')
        echo "  $i) $date ($size)"
        ((i++))
    done

    echo ""
    echo -n "Select backup to restore (1-${#backups[@]}), or 'c' to cancel: "
    read -r selection

    if [[ "$selection" =~ ^[Cc]$ ]]; then
        echo "Cancelled"
        return
    fi

    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#backups[@]} ]; then
        error_exit "Invalid selection"
    fi

    local selected_backup="${backups[$((selection-1))]}"

    warn_msg "⚠️  This will replace your current entries!"
    echo -n "Are you sure? Type 'yes' to confirm: "
    read -r confirm

    if [ "$confirm" != "yes" ]; then
        echo "Cancelled"
        return
    fi

    # Backup current state before restoring
    echo "Creating safety backup of current state..."
    backup_journal

    # Restore
    echo -e "${BLUE}Restoring from backup...${NC}"
    if tar -xzf "$selected_backup" -C "$JOURNAL_DIR" 2>/dev/null; then
        success_msg "✅ Journal restored successfully"
    else
        error_exit "Failed to restore backup"
    fi
}

# Get daily prompt
get_daily_prompt() {
    local day_of_week=$(date '+%A' | tr '[:upper:]' '[:lower:]')
    local day_prompt_file="$JOURNAL_DIR/prompts-${day_of_week}.md"
    local custom_prompts_file="$JOURNAL_DIR/prompts.md"

    # Priority 1: Check for day-of-week specific prompts
    if [ -f "$day_prompt_file" ] && [ -s "$day_prompt_file" ]; then
        # Read random line from day-specific prompt file
        local count=$(wc -l < "$day_prompt_file" | tr -d ' ')
        if [ "$count" -gt 0 ]; then
            local random_line=$((RANDOM % count + 1))
            local prompt=$(sed -n "${random_line}p" "$day_prompt_file")
            if [ -n "$prompt" ]; then
                echo "$prompt"
                return
            fi
        fi
    fi

    # Priority 2: Check for custom prompts file
    if [ -f "$custom_prompts_file" ] && [ -s "$custom_prompts_file" ]; then
        local count=$(wc -l < "$custom_prompts_file" | tr -d ' ')
        if [ "$count" -gt 0 ]; then
            # Use day of year for consistent daily prompt from custom file
            local day_of_year=$(date '+%j')
            local line_num=$((day_of_year % count + 1))
            local prompt=$(sed -n "${line_num}p" "$custom_prompts_file")
            if [ -n "$prompt" ]; then
                echo "$prompt"
                return
            fi
        fi
    fi

    # Priority 3: Default prompts
    local prompts=(
        "What made you smile today?"
        "What challenged you today?"
        "What are you grateful for right now?"
        "What did you learn today?"
        "What would you do differently?"
        "What progress did you make?"
        "What's on your mind?"
        "Who inspired you today?"
        "What surprised you?"
        "What are you looking forward to?"
        "What did you accomplish today?"
        "What's something you're proud of?"
        "What helped you grow today?"
        "What made today unique?"
        "What connections did you make?"
        "What decision are you facing?"
        "What pattern did you notice?"
        "What do you need to let go of?"
        "What energized you today?"
        "What drained your energy?"
    )

    # Use date as seed for consistent daily prompt
    local day_of_year=$(date '+%j')
    local index=$((day_of_year % ${#prompts[@]}))

    echo "${prompts[$index]}"
}

# Parse arguments
ENTRY_DATE=$(date '+%Y-%m-%d')
USE_TIMESTAMP=false
QUICK_CAPTURE=""
LIST_SORT_ORDER=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -l|--list)
            shift
            # Check if next arg is --oldest-first
            if [[ "$1" == "--oldest-first" ]]; then
                LIST_SORT_ORDER="oldest-first"
                shift
            fi
            list_entries "$LIST_SORT_ORDER"
            exit 0
            ;;
        --oldest-first)
            # This handles the case where --oldest-first appears before --list
            LIST_SORT_ORDER="oldest-first"
            shift
            ;;
        -y|--yesterday)
            ENTRY_DATE=$(date -v-1d '+%Y-%m-%d' 2>/dev/null || date -d 'yesterday' '+%Y-%m-%d' 2>/dev/null)
            shift
            ;;
        -d|--date)
            if [ -z "$2" ]; then
                error_exit "Date argument required for --date flag"
            fi
            ENTRY_DATE=$(parse_date "$2")
            shift 2
            ;;
        -t|--time)
            USE_TIMESTAMP=true
            shift
            ;;
        -s|--search)
            if [ -z "$2" ]; then
                error_exit "Search query required"
            fi
            search_entries "$2"
            exit 0
            ;;
        -w|--week)
            open_week
            exit 0
            ;;
        --tag)
            if [ -z "$2" ]; then
                error_exit "Tag required"
            fi
            filter_by_tag "$2"
            exit 0
            ;;
        --stats)
            show_stats
            exit 0
            ;;
        --export)
            if [ -z "$2" ]; then
                error_exit "Export format required (html/pdf)"
            fi
            if [ "$2" = "html" ]; then
                export_html
            elif [ "$2" = "pdf" ]; then
                export_pdf
            else
                error_exit "Unknown export format: $2 (use html or pdf)"
            fi
            exit 0
            ;;
        --random)
            show_random
            exit 0
            ;;
        --diff)
            if [ -z "$2" ]; then
                error_exit "Date required for --diff"
            fi
            show_diff "$2"
            exit 0
            ;;
        --archive)
            if [ -z "$2" ]; then
                error_exit "Year required for --archive"
            fi
            archive_entries "$2" "$3"
            exit 0
            ;;
        --prompt)
            get_daily_prompt
            exit 0
            ;;
        --backup)
            backup_journal
            exit 0
            ;;
        --restore)
            restore_journal
            exit 0
            ;;
        -*)
            error_exit "Unknown option: $1\nUse --help for usage information"
            ;;
        *)
            # Treat as quick capture text
            QUICK_CAPTURE="$1"
            shift
            ;;
    esac
done

# Handle quick capture
if [ -n "$QUICK_CAPTURE" ]; then
    quick_capture "$QUICK_CAPTURE"
    exit 0
fi

# Main logic
check_dependencies

# Handle timestamped entries
if [ "$USE_TIMESTAMP" = true ]; then
    TIMESTAMP=$(date '+%H%M')
    FILENAME="$JOURNAL_DIR/entries/$ENTRY_DATE-$TIMESTAMP.md"
else
    FILENAME="$JOURNAL_DIR/entries/$ENTRY_DATE.md"
fi

EDITOR_CMD=$(get_editor)

# Create journal directory if it doesn't exist
if [ ! -d "$JOURNAL_DIR" ]; then
    if ! mkdir -p "$JOURNAL_DIR/entries" 2>/dev/null; then
        error_exit "Cannot create journal directory: $JOURNAL_DIR\n\nCheck that you have write permissions to the parent directory.\nYou can also set a custom location with:\n  export JOURNAL_DIR=\"/path/to/your/journal\""
    fi
else
    mkdir -p "$JOURNAL_DIR/entries"
fi

cd "$JOURNAL_DIR" || error_exit "Cannot access journal directory: $JOURNAL_DIR\n\nCheck that the directory exists and you have permissions to access it."

# Initialize or check git repo
USE_GIT=true
init_repo || USE_GIT=false

# Pull latest changes if git is available
if [ "$USE_GIT" = true ] && git remote get-url origin &> /dev/null; then
    echo "Syncing with remote..."
    if ! git pull origin "$GIT_BRANCH" --rebase 2>/dev/null; then
        warn_msg "Failed to pull from remote. Continuing with local changes..."
    fi
fi

# Create entry if it doesn't exist
if [ ! -f "$FILENAME" ]; then
    # Check for template
    if [ -f "$JOURNAL_DIR/template.md" ]; then
        cat "$JOURNAL_DIR/template.md" > "$FILENAME"
        # Replace {{date}} placeholder if it exists
        sed -i.bak "s/{{date}}/$ENTRY_DATE/g" "$FILENAME" && rm "${FILENAME}.bak"
    else
        echo "# $ENTRY_DATE" > "$FILENAME"
        echo "" >> "$FILENAME"

        # Add daily prompt if not disabled
        if [ "$DISABLE_PROMPTS" != "true" ]; then
            prompt=$(get_daily_prompt)
            echo "**Prompt**: $prompt" >> "$FILENAME"
            echo "" >> "$FILENAME"
        fi
    fi

    if [ "$USE_TIMESTAMP" = true ]; then
        success_msg "Created new entry: $ENTRY_DATE-$TIMESTAMP.md"
    else
        success_msg "Created new entry: $ENTRY_DATE.md"
    fi
else
    if [ "$USE_TIMESTAMP" = true ]; then
        echo "Opening existing entry: $ENTRY_DATE-$TIMESTAMP.md"
    else
        echo "Opening existing entry: $ENTRY_DATE.md"
    fi
fi

# Get file hash before editing (to detect changes)
BEFORE_HASH=$(md5sum "$FILENAME" 2>/dev/null || md5 -q "$FILENAME" 2>/dev/null)

# Open in editor
$EDITOR_CMD "$FILENAME"

# Only commit if git is enabled and file was modified
if [ "$USE_GIT" = true ]; then
    AFTER_HASH=$(md5sum "$FILENAME" 2>/dev/null || md5 -q "$FILENAME" 2>/dev/null)

    if [ "$BEFORE_HASH" != "$AFTER_HASH" ]; then
        echo ""

        # Auto-sync if configured
        if [ "$AUTOSYNC" = "true" ]; then
            git add "$FILENAME"
            git commit -m "Journal entry for $ENTRY_DATE"

            if git remote get-url origin &> /dev/null; then
                if git push origin "$GIT_BRANCH"; then
                    success_msg "✅ Changes auto-committed and pushed!"
                else
                    warn_msg "Failed to push. Run 'git push' manually when ready."
                fi
            else
                success_msg "✅ Changes auto-committed locally"
            fi
        else
            echo -n "Commit changes? (y/n): "
            read -r commit_response

            if [[ "$commit_response" =~ ^[Yy]$ ]]; then
                git add "$FILENAME"
                git commit -m "Journal entry for $ENTRY_DATE"

                if git remote get-url origin &> /dev/null; then
                    echo -n "Push to remote? (y/n): "
                    read -r push_response

                    if [[ "$push_response" =~ ^[Yy]$ ]]; then
                        if git push origin "$GIT_BRANCH"; then
                            success_msg "✅ Changes committed and pushed!"
                        else
                            warn_msg "Failed to push. Run 'git push' manually when ready."
                        fi
                    else
                        success_msg "✅ Changes committed locally"
                    fi
                else
                    success_msg "✅ Changes committed locally"
                fi
            fi
        fi
    else
        echo "No changes detected."
    fi
fi
